title: "Swift集合类型协议浅析-下"
description: "Swift是一门面向协议的语言，协议可以被扩展，来给遵循该协议的类型提供方法等具体实现，通过扩展协议，我们可以为协议所要求的方法提供默认实现。在Swift出现以前，协议在iOS中就十分重要，想想UITableViewDataSource 和 UITableViewDelegate 等协议的讨论，可以说他们每天出现在我们的脑海里；使用Swift编程中一定会用到标准库中的协议，例如Array就是一个继承了10个协议的Struct，Bool类型是一个继承了7个协议的Struct；在这篇系列文章中，我们尝试去解读一些基础协议的内部关系和逻辑，向你展示Swift如此强大的秘密；本篇是Swift集合类型协议浅析的下篇，在这篇文章中我们继续围绕集合类型协议展开讨论，侧重点更多的关注String相关的周边协议"
category: programming
tags: swift, ios, protocol

# 引言

本篇是Swift集合类型协议浅析的下篇，在这篇文章中我们继续围绕集合类型协议展开讨论，侧重点更多的关注String相关的周边协议。

# StringProtocol

代表一个字符串，这个字符串是由字符构成的集合，StringProtocol协议抽象了字符串的使用场景，比如 `uppercased()`, `lowercased()`，还有 `comparable`、`collection` 等。在标准库中，只有String和SubString类型遵循StringProtocol协议，可以直接使用==对SubString和String进行判断，不需要类型转换

```swift
let helloSwift = "Hello Swift"
let swift = helloSwift[helloSwift.index(helloSwift.startIndex, offsetBy: 6)...]

// comparing a substring to a string
swift == "Swift"  // true
```

也可以遍历 substring，或者从 substring 截取子字符串。 在标准库里也有一小部分函数使用 StringProtocol 类型作为参数。比如把一个字符串转换为整型就是：`init(text: StringProtocol)`。 虽然你可能不关心是 string 和 substring，但是使用 StringProtocol 作为参数类型，调用者就不用进行类型转换，对他们会友好很多。

# CustomStringConvertible & CustomDebugStringConvertible

使用文本方式打印输出对象是一个常见场景，Swift提供了多种方式；

- print 使用String(describing:)初始化
- debugPrint使用String(reflecting:)
- dump使用Mirror(reflecting:)反射机制

| Function   | Protocol                     | Required Property |
| ---------- | ---------------------------- | ----------------- |
| print      | CustomStringConvertible      | description       |
| debugPrint | CustomDebugStringConvertible | debugDescription  |
| dump       | CustomReflectable            | customMirror      |

来看一个例子

```swift
struct BankCard {
    let bankName: String
    let cardNumber: Int
}
let bankcard = BankCard(bankName: "CBC",cardNumber: 123232324565)
// BankCard(bankName: "CBC", cardNumber: 123232324565)

extension BankCard: CustomStringConvertible {
    var description: String {
        return "\(self.bankName) \(self.cardNumber)"
    }
}
print(bankcard)
// CBC 123232324565
```

```swift
extension BankCard: CustomDebugStringConvertible {
    var debugDescription: String {
        return """
        BankName: \(self.bankName)
        CardNumber: \(self.cardNumber)
        """
} }
```

**dump**

```swift
func dump<T>(_ value: T, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T

/* * - T：是要打印的参数，是一个范型，也就是支持输出各种类型 

* - name： 默认是空白，如果加上则会在打印内容前加入这个name 

* - indent：缩进，默认是0，如果设置则会向前缩进相应的空白 

* - maxDepth：最大深度，默认全部打印，可以根据层级需要设置这个参数 

* - maxItems：最大条数，默认是全部打印，如果需要限制内容，可以设置这个参数

 */
```

```swift
let names = ["apple", "orange", "banana"]
dump(names)

print(names)

let iPhones = ["iPhoneX": 9688, "iPhone8 plus": 7888, "iphone8": 6888]
dump(iPhones)

//输出
/*
▿ 3 elements
  - "apple"
  - "orange"
  - "banana"
["apple", "orange", "banana"]
▿ 3 key/value pairs
  ▿ (2 elements)
    - key: "iPhoneX"
    - value: 9688
  ▿ (2 elements)
    - key: "iPhone8 plus"
    - value: 7888
  ▿ (2 elements)
    - key: "iphone8"
    - value: 6888
*/
```

- 打印log的时候，可以取代print，打印更详细的内容
- 需要在控制台打印数组或者字典的时候，用dump输出的东西更立体，不会像print一样打印出来是一行，对于特别大的数组或者字典很好用
- debug的时候能直接打印出对象的信息，我们debug的时候常常会打断点，然后查看对象里的参数的值，用dump相当于把参数的那个界面全部展开并打印到了控制台上

# LosslessStringConvertible

遵循此协议的类型，可以被转换为String，同时与此相反，可以再从String转换回原始类型，没有任何信息丢失;

![](/assets/images/string.png)

协议的继承关系如上图所示，很多系统类型已经实现了**LosslessStringConvertible**，所以才能与String之间互现转换，如Int，Int8，Int32，Int64 , Bool , Character , Double , Float等

遵循协议**需要实现init?(_ description: String) 和**   **description**

```swift
extension FlightCode: LosslessStringConvertible {
    public init?(_ description: String) {
        let components = description.split(separator: " ")
        guard components.count == 2,
            let airlineCode = components.first,
            let number = components.last,
            let flightNumber = Int(number)
        else {
            return nil
        }
        self.airlineCode = String(airlineCode)
        self.flightNumber = flightNumber
    }
}
let flight = FlightCode(airlineCode: "AA",
                        flightNumber: 1)

String(flight)
// "AA 1"

FlightCode(String(flight))
// FlightCode(airlineCode: "AA", flightNumber: 1)
```

# ExpressibleByUnicodeScalarLiteral,ExpressibleByExtendedGraphemeClusterLiteral,ExpressibleByStringLiteral

String字面量使用引号表示，当封闭的值包含单个字符集群时，同样的语法也可以表示字符集群文字;当封闭的值包含单个字符值时，同样的语法也可以表示Unicode标量文字。

```swift
// ExpressibleByUnicodeScalarLiteral 
let unicodeScalar: Unicode.Scalar = "A"

// ExpressibleByExtendedGraphemeClusterLiteral 
let character: Character = "A"

// ExpressibleByStringLiteral 
let string: String = "A"
```

**可扩展的字形集群**

每一个 Swift 的 Character类型实例都表示了单一的*扩展字形集群*。扩展字形集群是一个或者多个有序的 Unicode 标量（当组合起来时）产生的单个人类可读字符。举例来说，字母 é以单个 Unicode 标量 é ( LATIN SMALL LETTER E WITH ACUTE, 或者 U+00E9)表示。总之，同样的字母也可以用一对标量——一个标准的字母 e ( LATINSMALL LETTER E,或者说  U+0065)，以及 COMBINING ACUTE ACCENT标量( U+0301)表示。 COMBINING ACUTE ACCENT标量会以图形方式应用到它前边的标量上，当 Unicode 文本渲染系统渲染时，就会把 e转换为 é来输出。

在这两种情况中，字母é都会作为单独的 Swift Character值以扩展字形集群来表示。在前者当中，集群包含了一个单独的标量；后者，则是两个标量的集群：

```swift
let eAcute: Character = "\u{E9}" // é
let combinedEAcute: Character = "\u{65}\u{301}" // e followed by 
// eAcute is é, combinedEAcute is é
```

扩展字形集群是一种非常灵活的把各种复杂脚本字符作为单一 Character值来表示的方法。比如说韩文字母中的音节能被表示为复合和分解序列两种。这两种表示在 Swift 中都完全合格于单一 Character值：

```swift
let precomposed: Character = "\u{D55C}" // 한
let decomposed: Character = "\u{1112}\u{1161}\u{11AB}" // ᄒ, ᅡ, ᆫ
// precomposed is 한, decomposed is 한
```

继承关系

![](/assets/images/literal.png)

所以初始化一个Unicode.Scalar通过包含多个scalar标量的字面量，或者多个字符字面量期望转成一个字符，都会失败

```swift
("ABC" as Unicode.Scalar) // Error
("ABC" as Character) // Error
```

**通过字面量初始化特定类型**

```swift
extension URL: ExpressibleByStringLiteral {
    public init(stringLiteral value: String) {
        guard let url = URL(string: "\(value)") else {
            preconditionFailure("This url: \(value) is not invalid")
        }
        self = url
    }
}

let url:URL = "https://www.baidu.com"

print(url)

//let urls = URL.init(string: "https://www.baidu.com")
```

上面这个例子扩展了URL类型，使其能够直接通过String字面量转换为URL，十分简洁，但是这种方式也有其弊端，开发中容易引起歧义。

# ExpressibleByStringInterpolation

字符串插值是Swift5的新特性；通常，字符串文字中的内插值被转换为字符串，使用String(describing:)；通过遵循ExpressibleByStringInterpolation 协议（这个协议继承ExpressibleByStringLiteral），这个类型可以定义StringInterpolation 通过字面量改变插值行为。

**ExpressibleByStringLiteral**

三个方法需要实现

```swift
init(stringLiteral value: String)
init(extendedGraphemeClusterLiteral value: String)
init(unicodeScalarLiteral value: String)
```

**ExpressibleByStringInterpolation** 

```swift
init(stringInterpolation: StringInterpolation)
```

要让一个类型遵循 ExpressibleByStringInterpolation，最基本的你需要：

- 让这个类型拥有一个类型为 StringInterpolation 的子类型，这个子类型遵循 StringInterpolationProtocol 并将负责解释插值
- 这个子类型仅需要实现 appendLiteral(_ literal: String) 方法，再选择一个或多个你自己想要支持的 appendInterpolation(...) 签名的方法
- 这个 StringInterpolation 子类型会作为“构造器”服务于你的主类型，然后编译器会调用那些 append… 方法一步一步地构造对象
- 然后你的主类型需要实现 init(stringInterpolation: StringInterpolation) ，它会用上一步的结果来实例化它自己。

你可以实现任何你喜欢的 appenInterpolation(...) 方法，这意味着你可以任意选择支持什么插值。这是一个带来巨大的可能性的超强功能。

**举个例子，如果你实现了** **func appendInterpolation(_ string: String, pad: Int)**，那么意味着你将可以用类似这样的插值：**"Hello \(name, pad: 10), how are you?"** **来构造你的类型。插值只需要匹配你的** **StringInterpolation** **子类型其中一个支持的** **appendInterpolation** **方法签名。**



# 参考

1. https://swift.gg/2019/04/22/swift5-stringinterpolation-part1/
2. <https://academy.realm.io/cn/posts/try-swift-soroush-khanlou-sequence-collection/>
3. <https://swift.gg/2017/02/20/why-is-dictionary-not-a-mutablecollection/>